# test-case-generator

### 需求分析：

#### 功能需求：

读入c代码，以及额外参数，额外参数包括用例数目和正负例比例。输出满足要求的用例集合。

可以多机并行生成不重复的用例。

可以证明生成的例子符合给定约束。

提供测试用例。


### 架构设计：

#### 项目目录设计如下：

src：python代码

resources：要分析的c代码

case：求解结果

#### 技术架构：

解析c代码，生成ast（抽象语法树）。

解析ast，将声明的变量提取出来，加入变量表中。

在ast中找到\_CONSTRAINT函数，并对\_CONSTRAINT函数中的每个语句进行解析，生成原始约束。

对原始约束进行化简，将含有\_LENGTH函数的变量指针转变为相应类型的数组加入变量表；对于&&运算符，将其分解为多个约束加入约束表；对于||运算符，随机抽取一个作为加入约束表中。

建立变量表和约束表的关联矩阵。

对关联矩阵进行分块，分解成多个互不相关的bubble。

对多个bubble进行并行求解。

将求解结果进行全排列，并将结果写入文件内。

对于负例的生成，在约束表中随机抽取一个不属于||运算的约束，并对其符号进行变异，即>变异为<，==变异为!=...等，再利用上述步骤进行求解。


### 实现技术：


#### 解析c文件

为了方便读取，我们规定了文件的书写格式都如作业要求中的示例那样。

解析c代码：调用python库pycparser，将c代码转换为ast树。

解析ast树：利用回溯算法，对ast进行遍历，并将其中声明的变量以及约束提取出来，分别装入变量表和约束表中。

对约束表进行化简：

1.对于其中\_LENGTH函数，找到其函数参数，并根据其约束来确定指针指向的数组长度的上下界，并随机生成符合约束的数组来替换变量表中的变量。

2.对于&&运算符，将其拆解为多个约束加入约束表中，再将原始约束从约束表中剔除。

3.对于||运算符，将其拆解为多个约束，并随机选择一个约束加入约束表中，并将该约束存储下来以便后续变异时略过该约束，再将原始约束从约束表中剔除。

#### 生成关联矩阵

对于上述步骤中生成的变量表和约束表，将其化为关联矩阵，例如：

声明表为：

int a；

int b；

int c；

约束表为：

b > 1;

b < 5;

a == 3;

其关联矩阵为：

0   0   1

1   1   0

0   0   0

对变量表和约束表进行遍历，生成上述矩阵。

利用并查集，对各个变量进行标注，并遍历上述矩阵，从而可以将其分解为多个不关联的矩阵，以及变量表。

#### 负测试用例约束

对于生成负测试用例，对于约束表进行变异，从约束表中随机选取一个约束，如果其为||运算产生的约束就重新选取，并将其运算符号进行变异，即>变异为<，==变异为!=，<变异为>，!=变异为==，>=变异为<=，<=变异为>=。这样可以保证利用变异后约束表求解的结果一定不满足原始的约束。

#### 关联矩阵求解

大体上共分为两步，第一步为寻找单变量约束并求解，第二步为挑选约束最多的变量随机赋值。
为每个变量单独存储其可行区间，并通过以上两步骤不断循环更新每个变量的可行区间，直至所有的约束都被删除。
过程中利用上文的关联矩阵方便地进行符合条件的约束与变量的查找。

单变量约束求解：遍历所有约束并取出有单个变量未取精确值的约束，对这样的单变量约束使用sympy求解得到一个可行区间，
并与该变量现有的可行区间取交集作为其新的可行区间存储。此时该约束已无未利用的信息，可将其删去。

进一步限制变量区间：对于形如a < b的约束，若为变量a确定了一个(0,10)的可行区间，则变量b的可行区间也应被限制为(0,+oo)。
因此，在每次为任一变量确定新的区间时（包括由此步骤确定的新的区间），都遍历所有约束找出包含当前变量并含一个其他未赋值变量的约束，
由当前变量的可行区间为未赋值变量确定它的可行区间并保存。

得到空集时状态回溯：在上两步中若新的可行区间为空集，则回溯到栈中上一个状态并重新进行变量随机赋值。
每个状态有最大回溯次数，若超过该次数则回溯到再上一个状态并重新赋值。

存储工作区变量：将当前的约束以及变量可行区间压入栈，以便在由于随机赋值时值不好造成无解时回溯到当前状态并重新赋值。

变量随机赋值：在有高斯约束时，为保证变量尽可能以高斯函数分布，优先对其在该变量目前的可行区间内以高斯函数赋随机值。
若无未处理的高斯约束，则优先取约束最多的变量，在其可行区间内随机赋值。在对变量赋值后遍历所有约束并将对应变量符号替换为赋的值。

结果输出：不断重复以上步骤直至删去所有约束。此时若仍有未确定精确值的变量，在其可行区间内随机赋值，直至每一个变量都有一个精确值。

#### 求解结果进行全排列

对于上述各个bubble生成的结果，首先利用hashset进行去重，然后利用深度优先遍历，对结果进行全排列，从而利用现有的结果得到最多的测试用例。

#### 结果验证

使用上文步骤处理后生成的约束，将每条测试用例中的变量与值使用sympy带入约束，并检查约束表达式是否成立，
对于正例要求所有表达式均成立，对于负例要求至少有一条表达式不成立。


## 运行设置

需要解析的c文件放在resources目录下

在根目录下运行 python ./src/main.py

运行参数：

--name // c program name

--n // test case number (default: 10000)  

--r // ratio of positive case (default: 0.5)  

--c // thread number (default: number of cores(-1))

生成完成，需要验证时，运行 python ./src/validate_cases.py


